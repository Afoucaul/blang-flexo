\chapter{Abstraction de l'API Rodin}

Nous souhaitons abstraire les fonctionnalités de gestion de projet de l'API Rodin, afin de fournir une surcouche simple d'utilisation.
Faisant écho aux scénarios de validation, nous présentons d'abord les fonctions abstraites que nous voulons pouvoir appeler sur cette surcouche.


\section{Aperçu de la surcouche}

Nous nous proposons de créer une classe \imtaInlinecode{java}{RodinApiHandle}, qui va proposer les différentes fonctions de la surcouche.
Cette classe présentera l'interface suivante :

% \begin{table}[H]
%     \centering
%     \begin{tabular}{| l | l | l |}
%         \hline
%         \multicolumn{1}{|c|}{Modificateurs} & \multicolumn{1}{|c|}{Signature} & \multicolumn{1}{|c|}{Description}\\
%         \hline\hline
%         \texttt{public static} & \texttt{IRodinProject createRodinProject(final String name)} & Création d'un projet Rodin\\
%         \hline
%         \texttt{public static} & \texttt{IRodinProject createEventbMachine(IRodinProject, final String name)} & Création d'une machine Event-B dans un projet\\
%         \hline
%     \end{tabular}
%     \caption{Interface externe de la surcouche Rodin}
%     \label{table:rodinApiHandle}
% \end{table}

\vspace{\baselineskip}
\begin{labeling}{public static}
    \setlength{\itemsep}{1.5em}

    \item [\javacode{public static}] \javacode{IRodinProject createRodinProject(final String name)}
        \begin{itemize}[label={}]
            \item Création d'un projet Rodin avec le nom donné.
            \item \textit{Dépend de :}
                \begin{itemize}
                    \item \javacode{org.eclipse.core.resources.IWorkspace}
                    \item \javacode{org.eclipse.core.resources.IProject}
                    \item \javacode{org.rodinp.core.IRodinProject}
                \end{itemize}
        \end{itemize}

    \item [\javacode{public static}] \javacode{IMachineRoot createEventbMachine(IRodinProject project, final String name)}
        \begin{itemize}[label={}]
            \item Création d'une machine Event-B dans le projet donné et avec le nom donné.
            \item \textit{Dépend de :}
                \begin{itemize}
                    \item \javacode{org.rodinp.core.IRodinProject}
                    \item \javacode{org.rodinp.core.IRodinFile}
                \end{itemize}
        \end{itemize}

\end{labeling}


\section{Défis de conception}

La conception d'une surcouche à Rodin n'est pas une entreprise si simple qu'il n'y paraît.
D'une part, l'abstraction des fonctionnalités nécessite une compréhension profonde de l'API, et une certaine rigueur vis-à-vis de la validation %
des opérations effectuées.
Par ailleurs, Rodin étant fondé sur Eclipse, il s'avère particulièrement difficile d'extraire son cœur.


\subsection{Validation des opérations réalisées}


\subsection{Extraction du cœur de Rodin}

Au sein de l'API de Rodin, l'implémentation de la méthode Event-B, est contenue dans les packages préfixés par \javacode{org.eventb.}.
La couche de gestion de projet et l'interface utilisateur, quant à elles, sont contenues dans les packages \javacode{org.rodinp.}.
Nous appelons la première région le cœur de Rodin, et la seconde, la couche externe.

La séparation entre ces deux régions est très floue.
Notamment, comme nous l'avons vu en section \ref{sec:rodinApiSummaryEvent}, les classes implémentant les éléments Event-B sont définies dans le cœur de Rodin, %
héritent de \javacode{EventBElement} qui appartient au cœur, mais étendent également \javacode{InternalElement} qui se situe dans la couche externe de l'API.
L'enjeu de cette abstraction est donc avant tout d'isoler les opérations de manipulation de projets et d'éléments.

Toutefois, la manipulation d'un projet Rodin implique une communication avec la base de données Rodin.
Or, celle-ci ne peut être acquise qu'à travers un \textit{workspace}, typiquement de la manière suivante~:

\begin{figure}[H]
\centering
\begin{imtaCode}{java}
final IWorkspace workspace = ResourcesPlugin.getWorkspace();
final IRodinDB rodinDB = RodinCore.valueOf(workspace.getRoot());
\end{imtaCode}
\caption{Acquisition de la base de données Rodin}
\label{fig:rodinDbAccess}
\end{figure}

Nous comprenons qu'un \textit{workspace} doit exister, et que le plugin \javacode{ResourcesPlugin} doit avoir été initialisé.
L'obstacle qui se dessine est précisément la nécessité de l'existence d'une instance d'\javacode{IWorkspace}~: en effet, comme l'indique la documentation %
de l'API d'Eclipse \cite{eclipseiworkspace}, cette interface n'a pas vocation à être étendue ni implémentée par les clients.
Concrètement, cela signifie qu'un \textit{workspace} n'est \textit{a priori} pas censé exister hors d'une instance d'Eclipse.
Ainsi, faire fonctionner le cœur de Rodin hors du mode plugin semble entravé par cette contrainte.

La solution idéale consiste à déterminer et à implémenter une méthode d'instanciation dynamique d'un \textit{workspace} Eclipse.
Cela permettrait de produire une bibliothèque de classes fermée et sans dépendances autres qu'à l'API de Rodin et à celle d'Eclipse.
Une telle bibliothèque serait relativement simple à intégrer à OpenFlexo.
Cette solution offrirait par effet de bord une preuve de concept de l'intégration d'une application RCP Eclipse à OpenFlexo.

Une alternative, nettement moins désirable, consisterait à lancer effectivement une instance de Rodin dans laquelle s'exécuterait un plugin, qui communiquerait %
en réseau, par exemple sur une socket Unix, avec l'instance d'OpenFlexo.
Cette solution, bien qu'elle ait le mérite de contourner l'obstacle, est très peu satisfaisante, car elle n'intègre pas à proprement parler Rodin dans l'écosystème OpenFlexo.
Par ailleurs, elle implique l'exécution d'une instance d'Eclipse en plus d'OpenFlexo, et entraîne une consommation peu utile de ressources supplémentaires.


\section{Développement de la surcouche}

% TODO
% On veut implémenter la solution 1

\subsection{Ouverture du \textit{workspace}}

Afin de pouvoir manipuler des projets Rodin et leurs éléments, il est primordial de disposer d'un \textit{workspace} ouvert.
Il faut donc trouver dans la base de code d'Eclipse quelle classe implémente l'interface \javacode{IWorkspace}, et déterminer une manière de l'instancier.

Une recherche du mot-clé \textit{workspace} dans le moteur de recherche GrepCode\footnote{%
\url{http://grepcode.com/search?query=workspace&start=0&entity=type&n=}} %
permet de trouver la classe \javacode{org.eclipse.core.internal.resources.Workspace}, et d'accéder à son code source \cite{eclipseworkspace}.
Notons au passage que le package \javacode{org.eclipse.core.internal.resources} ne figure pas sur la vue globale des packages de l'API Eclipse \cite{eclipseapioverview}.
Nous essayons donc d'instancier la classe \javacode{Workspace}, avec le code minimal suivant~:

\begin{imtaCode}{java}
import org.eclipse.core.internal.resources.Workspace;    

public class Main {
    public static void main(String[] args) {
        Workspace workspace = new Workspace();
    }
}
\end{imtaCode}

L'exécution de cette classe conduit malheureusement à une exception \javacode{ExceptionInInitializerError}, avec la trace suivante :

\begin{imtaConsole}
Exception in thread "main" java.lang.ExceptionInInitializerError
	at Test.Main.main(Main.java:6)
Caused by: java.lang.NullPointerException
	at org.eclipse.core.internal.runtime.InternalPlatform.getOS(InternalPlatform.java:395)
	at org.eclipse.core.runtime.Platform.getOS(Platform.java:1126)
	at org.eclipse.core.internal.resources.Workspace.<clinit>(Workspace.java:84)
	... 1 more
\end{imtaConsole}

Cette trace nous informe qu'un appel à la méthode statique \javacode{Platform.getOS} a été effectué, mais à échoué lors d'un appel à la méthode d'instance %
\javacode{InternalPlatform.getOS}.
Nous souhaitons investiguer pour trouver la source de l'erreur \javacode{NullPointerException}.


\subsubsection{Analyse du \textit{bytecode} de \texttt{Platform.getOS}}

Ne disposant pas du code source de la classe \javacode{Platform}, nous pouvons malgré tout inspecter le bytecode associé.
Nous trouvons ainsi la définition de la méthode \javacode{getOS}~:

\begin{imtaCode}{java}
// Method descriptor #264 ()Ljava/lang/String;
// Stack: 1, Locals: 0
public static java.lang.String getOS();
  0  invokestatic org.eclipse.core.internal.runtime.InternalPlatform.getDefault() : org.eclipse.core.internal.runtime.InternalPlatform [398]
  3  invokevirtual org.eclipse.core.internal.runtime.InternalPlatform.getOS() : java.lang.String [389]
  6  areturn
    Line numbers:
      [pc: 0, line: 1126]
\end{imtaCode}

La documentation d'Oracle nous renseigne sur le sens des instructions \texttt{invokestatic} \cite{javainvokestatic} et \texttt{invokevirtual} \cite{javainvokevirtual}~: %
la première correspond à l'appel d'une méthode statique, et la seconde à l'appel d'une méthode d'instance.
Nous comprenons donc que la méthode \javacode{Platform.getOS} appelle en premier lieu la méthode statique \javacode{InternalPlatform.getDefault}, %
puis appelle sur l'instance retournée la méthode \javacode{getOS}, et renvoie enfin l'instance de \javacode{String} retournée.
Les appels étant naturellement chaînés façon Java, le code source ressemble probablement à ceci~:

\begin{imtaCode}{java}
public static String getOS() {
    return InternalPlatform.getDefault().getOS();
}
\end{imtaCode}

Si par ailleurs nous essayons d'invoquer la méthode \javacode{InternalPlatform.getDefault}, aucune erreur ne survient.
L'erreur est donc levée à l'intérieur de l'appel à la méthode d'instance \javacode{InternalPlatform.getOS}, comme le laissait entendre la trace d'erreur.


\subsubsection{Analyse du \textit{bytecode} de \texttt{InternalPlatform.getOS}}

Nous nous intéressons maintenant à la méthode d'instance \javacode{InternalPlatform.getOS}, dont le bytecode est le suivant~:

\begin{imtaCode}{java}
// Method descriptor #572 ()Ljava/lang/String;
// Stack: 2, Locals: 1
public java.lang.String getOS();
 0  aload_0 [this]
 1  invokevirtual org.eclipse.core.internal.runtime.InternalPlatform.getBundleContext() : org.osgi.framework.BundleContext [897]
 4  ldc <String "osgi.os"> [18]
 6  invokeinterface org.osgi.framework.BundleContext.getProperty(java.lang.String) : java.lang.String [955] [nargs: 2]
11  areturn
  Line numbers:
    [pc: 0, line: 395]
  Local variable table:
    [pc: 0, pc: 12] local: this index: 0 type: org.eclipse.core.internal.runtime.InternalPlatform
\end{imtaCode}

Comme l'indique la documentation d'Oracle, l'instruction \texttt{aload} \cite{javaaload} pousse une variable sur la pile de la JVM, et l'instruction %
\texttt{ldc} \cite{javaldc} y pousse une valeur scalaire.
Le code source de cette méthode ressemble donc probablement à celui qui suit~:

\begin{imtaCode}{java}
public String getOS() {
    return this.getBundleContext().getProperty("osgi.os");
}
\end{imtaCode}

Nous cherchons la source d'une \javacode{NullPointerException}.
Or, nous savons que \javacode{this} ne pointe pas sur \javacode{null}.
