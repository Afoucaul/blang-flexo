\chapter{Abstraction de l'API Rodin}\label{sec:apihandle}

Nous souhaitons abstraire les fonctionnalités de gestion de projet de l'API Rodin, afin de fournir une surcouche simple d'utilisation.
Faisant écho aux scénarios de validation, nous présentons d'abord les fonctions abstraites que nous voulons pouvoir appeler sur cette surcouche.


\section{Aperçu de la surcouche}

Nous nous proposons de créer une classe \imtaInlinecode{java}{RodinApiHandle}, qui va proposer les différentes fonctions de la surcouche.
Cette classe présentera l'interface suivante :

% \begin{table}[H]
%     \centering
%     \begin{tabular}{| l | l | l |}
%         \hline
%         \multicolumn{1}{|c|}{Modificateurs} & \multicolumn{1}{|c|}{Signature} & \multicolumn{1}{|c|}{Description}\\
%         \hline\hline
%         \texttt{public static} & \texttt{IRodinProject createRodinProject(final String name)} & Création d'un projet Rodin\\
%         \hline
%         \texttt{public static} & \texttt{IRodinProject createEventbMachine(IRodinProject, final String name)} & Création d'une machine Event-B dans un projet\\
%         \hline
%     \end{tabular}
%     \caption{Interface externe de la surcouche Rodin}
%     \label{table:rodinApiHandle}
% \end{table}

\vspace{\baselineskip}
\begin{labeling}{public static}
    \setlength{\itemsep}{1.5em}

    \item [\javacode{public static}] \javacode{IRodinProject createRodinProject(final String name)}
        \begin{itemize}[label={}]
            \item Création d'un projet Rodin avec le nom donné.
            \item \textit{Dépend de :}
                \begin{itemize}
                    \item \javacode{org.eclipse.core.resources.IWorkspace}
                    \item \javacode{org.eclipse.core.resources.IProject}
                    \item \javacode{org.rodinp.core.IRodinProject}
                \end{itemize}
        \end{itemize}

    \item [\javacode{public static}] \javacode{IMachineRoot createEventbMachine(IRodinProject project, final String name)}
        \begin{itemize}[label={}]
            \item Création d'une machine Event-B dans le projet donné et avec le nom donné.
            \item \textit{Dépend de :}
                \begin{itemize}
                    \item \javacode{org.rodinp.core.IRodinProject}
                    \item \javacode{org.rodinp.core.IRodinFile}
                \end{itemize}
        \end{itemize}

\end{labeling}


\section{Défis de conception}

La conception d'une surcouche à Rodin n'est pas une entreprise si simple qu'il n'y paraît.
D'une part, l'abstraction des fonctionnalités nécessite une compréhension profonde de l'API, et une certaine rigueur vis-à-vis de la validation %
des opérations effectuées.
Par ailleurs, Rodin étant fondé sur Eclipse, il s'avère particulièrement difficile d'extraire son cœur.


\subsection{Validation des opérations réalisées}


\subsection{Extraction du cœur de Rodin}

Au sein de l'API de Rodin, l'implémentation de la méthode Event-B, est contenue dans les packages préfixés par \javacode{org.eventb.}.
La couche de gestion de projet et l'interface utilisateur, quant à elles, sont contenues dans les packages \javacode{org.rodinp.}.
Nous appelons la première région le cœur de Rodin, et la seconde, la couche externe.

La séparation entre ces deux régions est très floue.
Notamment, comme nous l'avons vu en section \ref{sec:rodinApiSummaryEvent}, les classes implémentant les éléments Event-B sont définies dans le cœur de Rodin, %
héritent de \javacode{EventBElement} qui appartient au cœur, mais étendent également \javacode{InternalElement} qui se situe dans la couche externe de l'API.
L'enjeu de cette abstraction est donc avant tout d'isoler les opérations de manipulation de projets et d'éléments.

Toutefois, la manipulation d'un projet Rodin implique une communication avec la base de données Rodin.
Or, celle-ci ne peut être acquise qu'à travers un \textit{workspace}, typiquement de la manière suivante~:

\begin{imtaCode}{java}
final IWorkspace workspace = ResourcesPlugin.getWorkspace();
final IRodinDB rodinDB = RodinCore.valueOf(workspace.getRoot());
\end{imtaCode}

Nous comprenons qu'un \textit{workspace} doit exister, et que le plugin \javacode{ResourcesPlugin} doit avoir été initialisé.
L'obstacle qui se dessine est précisément la nécessité de l'existence d'une instance d'\javacode{IWorkspace}~: en effet, comme l'indique la documentation %
de l'API d'Eclipse \cite{eclipseiworkspace}, cette interface n'a pas vocation à être étendue ni implémentée par les clients.
Concrètement, cela signifie qu'un \textit{workspace} n'est \textit{a priori} pas censé exister hors d'une instance d'Eclipse.
Ainsi, faire fonctionner le cœur de Rodin hors du mode plugin semble entravé par cette contrainte.

La solution idéale consiste à déterminer et à implémenter une méthode d'instanciation dynamique d'un \textit{workspace} Eclipse.
Cela permettrait de produire une bibliothèque de classes fermée et sans dépendances autres qu'à l'API de Rodin et à celle d'Eclipse.
Une telle bibliothèque serait relativement simple à intégrer à OpenFlexo.
Cette solution offrirait par effet de bord une preuve de concept de l'intégration d'une application RCP Eclipse à OpenFlexo.

Une alternative, nettement moins désirable, consisterait à lancer effectivement une instance de Rodin dans laquelle s'exécuterait un plugin, qui communiquerait %
en réseau, par exemple sur une socket Unix, avec l'instance d'OpenFlexo.
Cette solution, bien qu'elle ait le mérite de contourner l'obstacle, est très peu satisfaisante, car elle n'intègre pas à proprement parler Rodin dans l'écosystème OpenFlexo.
Par ailleurs, elle implique l'exécution d'une instance d'Eclipse en plus d'OpenFlexo, et entraîne une consommation peu utile de ressources supplémentaires.


\section{Développement d'une bibliothèque indépendante d'Eclipse}

Nous souhaitons implémenter la surcouche de Rodin en tant que bibliothèque de classes qui ne dépend pas d'une instance d'Eclipse en cours d'exécution.
Comme Rodin est malgré tout conçu en tant que plugin d'Eclipse, il nécessite une partie du cœur d'Eclipse, que nous devons initialiser nous-mêmes.

\subsection{Ouverture du \textit{workspace}}

Afin de pouvoir manipuler des projets Rodin et leurs éléments, il est primordial de disposer d'un \textit{workspace} ouvert.
Il faut donc trouver dans la base de code d'Eclipse quelle classe implémente l'interface \javacode{IWorkspace}, et déterminer une manière de l'instancier.

Une recherche du mot-clé \textit{workspace} dans le moteur de recherche GrepCode\footnote{%
\url{http://grepcode.com/search?query=workspace&start=0&entity=type&n=}} %
permet de trouver la classe \javacode{org.eclipse.core.internal.resources.Workspace}, et d'accéder à son code source \cite{eclipseworkspace}.
Notons au passage que le package \javacode{org.eclipse.core.internal.resources} ne figure pas sur la vue globale des packages de l'API Eclipse \cite{eclipseapioverview}.
Nous essayons donc d'instancier la classe \javacode{Workspace}, avec le code minimal suivant~:

\begin{imtaCode}{java}
import org.eclipse.core.internal.resources.Workspace;    

public class Main {
    public static void main(String[] args) {
        Workspace workspace = new Workspace();
    }
}
\end{imtaCode}

L'exécution de cette classe conduit malheureusement à une exception \javacode{ExceptionInInitializerError}, avec la trace suivante :

\begin{imtaConsole}
Exception in thread "main" java.lang.ExceptionInInitializerError
	at Test.Main.main(Main.java:6)
Caused by: java.lang.NullPointerException
	at org.eclipse.core.internal.runtime.InternalPlatform.getOS(InternalPlatform.java:395)
	at org.eclipse.core.runtime.Platform.getOS(Platform.java:1126)
	at org.eclipse.core.internal.resources.Workspace.<clinit>(Workspace.java:84)
	... 1 more
\end{imtaConsole}

Cette trace nous informe qu'un appel à la méthode statique \javacode{Platform.getOS} a été effectué, mais à échoué lors d'un appel à la méthode d'instance %
\javacode{InternalPlatform.getOS}.
Nous souhaitons investiguer pour trouver la source de l'erreur \javacode{NullPointerException}.


\subsubsection{Analyse du \textit{bytecode} de \texttt{Platform.getOS}}

Ne disposant pas du code source de la classe \javacode{Platform}, nous pouvons malgré tout inspecter le bytecode associé.
Nous trouvons ainsi la définition de la méthode \javacode{getOS}~:

\begin{imtaCode}{java}
// Method descriptor #264 ()Ljava/lang/String;
// Stack: 1, Locals: 0
public static java.lang.String getOS();
  0  invokestatic org.eclipse.core.internal.runtime.InternalPlatform.getDefault() : org.eclipse.core.internal.runtime.InternalPlatform [398]
  3  invokevirtual org.eclipse.core.internal.runtime.InternalPlatform.getOS() : java.lang.String [389]
  6  areturn
    Line numbers:
      [pc: 0, line: 1126]
\end{imtaCode}

La documentation d'Oracle nous renseigne sur le sens des instructions \texttt{invokestatic} \cite{javainvokestatic} et \texttt{invokevirtual} \cite{javainvokevirtual}~: %
la première correspond à l'appel d'une méthode statique, et la seconde à l'appel d'une méthode d'instance.
Nous comprenons donc que la méthode \javacode{Platform.getOS} appelle en premier lieu la méthode statique \javacode{InternalPlatform.getDefault}, %
puis appelle sur l'instance retournée la méthode \javacode{getOS}, et renvoie enfin l'instance de \javacode{String} retournée.
Les appels étant naturellement chaînés façon Java, le code source ressemble probablement à ceci~:

\begin{imtaCode}{java}
public static String getOS() {
    return InternalPlatform.getDefault().getOS();
}
\end{imtaCode}

Si par ailleurs nous essayons d'invoquer la méthode \javacode{InternalPlatform.getDefault}, aucune erreur ne survient.
L'erreur est donc levée à l'intérieur de l'appel à la méthode d'instance \javacode{InternalPlatform.getOS}, comme le laissait entendre la trace d'erreur.


\subsubsection{Analyse du \textit{bytecode} de \texttt{InternalPlatform.getOS}}

Nous nous intéressons maintenant à la méthode d'instance \javacode{InternalPlatform.getOS}, dont le bytecode est le suivant~:

\begin{imtaCode}{java}
// Method descriptor #572 ()Ljava/lang/String;
// Stack: 2, Locals: 1
public java.lang.String getOS();
 0  aload_0 [this]
 1  invokevirtual org.eclipse.core.internal.runtime.InternalPlatform.getBundleContext() : org.osgi.framework.BundleContext [897]
 4  ldc <String "osgi.os"> [18]
 6  invokeinterface org.osgi.framework.BundleContext.getProperty(java.lang.String) : java.lang.String [955] [nargs: 2]
11  areturn
  Line numbers:
    [pc: 0, line: 395]
  Local variable table:
    [pc: 0, pc: 12] local: this index: 0 type: org.eclipse.core.internal.runtime.InternalPlatform
\end{imtaCode}

Comme l'indique la documentation d'Oracle, l'instruction \texttt{aload} \cite{javaaload} pousse une variable sur la pile de la JVM, et l'instruction %
\texttt{ldc} \cite{javaldc} y pousse une valeur scalaire.
Le code source de cette méthode est donc équivalent à celui qui suit~:

\begin{imtaCode}{java}
public String getOS() {
    return this.getBundleContext().getProperty("osgi.os");
}
\end{imtaCode}

Nous cherchons la source d'une \javacode{NullPointerException}.
Or, nous savons que \javacode{this} ne pointe pas sur \javacode{null}.
Nous testons donc l'appel \javacode{InternalPlatform.getDefault().getBundleContext()}, correspondant à l'invocation de la méthode d'instance %
\javacode{InternalPlatform.getBundleContext}, et nous remarquons que la valeur retournée est \javacode{null}.
L'erreur \javacode{NullPointerException} est donc levée par l'invocation de la méthode \javacode{BundleContext.getProperty} sur une référence nulle.

En inspectant le code source de la classe \javacode{InternalPlatform}, nous découvrons que la méthode d'instance \javacode{getBundleContext} renvoie l'attribut \javacode{context}, %
qui est initialisé par la méthode \javacode{start}.
Comme cette dernière reçoit un \javacode{BundleContext} en argument, nous initialisons l'instance d'\javacode{InternalPlatform} de la façon suivante~:

\begin{imtaCode}{java}
// Initialisation du framework
FrameworkFactory frameworkFactory = ServiceLoader.load(FrameworkFactory.class).iterator().next();
Map<String, String> config = new HashMap<String, String>();
Framework framework = frameworkFactory.newFramework(config);
framework.start();

// Démarrage de la plateforme
BundleContext runtimeContext = framework.getBundleContext();
InternalPlatform.getDefault().start(runtimeContext);

// Instanciation du workspace
Workspace workspace = new Workspace();
\end{imtaCode}

L'exécution de ce code ne produit plus la même exception, comme le montre la trace~:

\begin{imtaConsole}
Exception in thread "main" java.lang.NullPointerException
	at org.eclipse.core.internal.resources.LocalMetaArea.<init>(LocalMetaArea.java:59)
	at org.eclipse.core.internal.resources.Workspace.<init>(Workspace.java:286)
	at test.Main.main(Main.java:207)
\end{imtaConsole}

Bien que l'instanciation du \textit{workspace} ne fonctionne toujours pas, l'initialisation de la plateforme ne lève plus d'erreur.
Nous continuons donc notre rétro-ingénierie sur la classe \javacode{LocalMetaArea}, dont l'instanciation semble être à la source de l'erreur.


\subsubsection{Analyse de la classe \texttt{LocalMetaArea}}

Nous trouvons les sources de la classe \javacode{LocalMetaArea} sur GrepCode \footnote{%
\url{http://grepcode.com/file/repository.grepcode.com/java/eclipse.org/4.4.1/org.eclipse.core/resources/3.9.1/org/eclipse/core/internal/resources/LocalMetaArea.java}}.
En nous intéressant à son constructeur, nous lisons le code suivant~:

\begin{imtaCode}{java}
public LocalMetaArea() {
    super();
    metaAreaLocation = ResourcesPlugin.getPlugin().getStateLocation();
    projectMetaLocation = metaAreaLocation.append(F_PROJECTS);
}
\end{imtaCode}

En testant indépendamment l'acquisition du plugin de gestion des ressources Eclipse, nous constatons qu'il n'est pas initialisé~:

\begin{imtaCode}{java}
System.out.println(ResourcesPlugin.getPlugin());
\end{imtaCode}
\vspace{-0.5cm}
\begin{imtaConsole}
null
\end{imtaConsole}

Après de nombreux essais infructueux, il apparaît très lourd d'initialiser ce plugin sans passer par l'initialisation traditionnelle d'Eclipse.


\subsection{Difficulté de la rétro-ingénierie~: vers une alternative}

En creusant de plus en plus profondément le code source et le \textit{bytecode} de l'API d'Eclipse, nous ressentons la lourdeur que représente l'instanciation d'un \textit{workspace}.
Cela est dû au fait que la classe \javacode{Workspace} est instanciée par Eclipse à l'initialisation.
Ainsi, pour ouvrir manuellement un \textit{workspace}, il faut reproduire au moins partiellement les étapes d'initialisation d'Eclipse, ce qui est fatalement très lourd.
Pour appuyer ce fait, la documentation de la classe \javacode{ResourcesPlugin} \cite{eclipseresourcesplugin} nous indique que le \textit{workspace} est censé être initialisé à travers la méthode %
\javacode{ResourcesPlugin.getWorkspace}~:\\

\begin{imtaQuote}
A typical sequence of events would be for a dependent plug-in to call\\ResourcesPlugin.getWorkspace().
Doing so would cause this plug-in to be activated and the workspace (if any) to be loaded from disk and initialized.
\end{imtaQuote}

Or, un appel à la méthode \javacode{getWorkspace} résulte en une erreur, tout comme un appel à la méthode \javacode{start}.
Nous comprenons qu'il sera très complexe de mettre en œuvre une partie de l'API Eclipse sans lancer toute la machinerie.

Afin de réaliser une preuve de concept de l'intégration de Rodin à OpenFlexo nous nous proposons d'implémenter une méthode alternative.
Celle-ci ne sera pas idéale, puisqu'elle ne permettra pas d'isoler le cœur de Rodin et de l'intégrer à OpenFlexo en tant que Technology Adapter~; %
Elle aura néanmoins le mérite de démontrer la faisabilité d'une telle intégration.


\section{Conception d'une surcouche en mode \textit{plugin}}

La solution que nous nous proposons de réaliser consiste à abstraire l'API de Rodin dans un fonctionnement en mode \textit{plugin}, et à faire communiquer une instance de Rodin %
avec l'instance d'OpenFlexo
Cette approche permet de s'affranchir des problèmes d'initialisation de \textit{workspace}, puisqu'Eclipse s'en charge alors à notre place.

% TODO
